
def max_score(S, marks):
    memo = {}
    def dp(S, marks):
        marks = tuple(sorted(marks))

     # If the current state is already computed, return the result
        if marks in memo:
            return memo[marks]
            
    # if there are no marks left, return the current score S
        if len(marks) == 0:
            return S
        else:
            max_s = 0
            for i in range(len(marks)):
                new_marks = list(marks[:i] + marks[i+1:])
    # Adjust the new marks based on the current mark's relation to S
                if marks[i] < S:
                    new_marks = [x + (S - marks[i]) for x in new_marks]
                    max_s = max(max_s, dp(marks[i], new_marks))
                else:
                    new_marks = [x - (marks[i] - S) for x in new_marks]
                    max_s = max(max_s, dp(marks[i], new_marks))
            memo[marks] = max_s
            return max_s
    return dp(S, marks)

#example usage
print(max_score(8, [5, 7, 1]))  # Output: 11
print(max_score(25, [18, 24, 21, 32, 27]))  # Output: 44
print(max_score(30, [13, 27, 41, 59, 28, 33, 39, 19, 52, 48, 55, 79]))  # Output: 205
